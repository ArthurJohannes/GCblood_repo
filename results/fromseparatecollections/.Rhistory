df$IDENTIFIER <- names (correlationsranked_namednum)
colnames (df) [1] <-  paste (j, "nr" , probe, sep = "")
allprofiles_list [[counterprobesets + counterprofiles]] <- df
counterprobesets <- counterprobesets + 1
}
counterprofiles <- counterprofiles + counterprobesets
counterdatasetsdown <- counterdatasetsdown - 1
counterdatasetsup <- counterdatasetsup + 1
print ("files left to do:")
print (counterdatasetsdown)
}
###############################################################################
#### Ranking gene expression profiles based on nr of testgenes hits
###############################################################################
#######################
## set number of top ranking genes in profile used for determining intersect with testgenes (now 25)
forintersect <- 25
#######################
allprofiles_listlength <- length (allprofiles_list)
profilename <-
character (); profilenr <-
numeric (); intersectsize <-
numeric () ;intersectgene_list <-
list();for (i  in 1:allprofiles_listlength) {
aa <-
allprofiles_list [[i]]; bb <-
as.character (aa [1:forintersect,2]); cc <-
intersect (testgenes,bb);profilename <-
c (profilename, colnames (aa) [1]); profilenr <-
c (profilenr, i); intersectsize <-
c (intersectsize,length (cc)); intersectgene_list [[i]] <- cc
}
df <- as.data.frame (cbind (profilename,profilenr,intersectsize))
df$profilename <- as.character(df$profilename)
df$profilenr <- as.numeric (as.character(df$profilenr))
df$intersectsize <- as.numeric (as.character(df$intersectsize))
dforder1 <- df [order (df$intersectsize,decreasing = TRUE),]
#### also keeping info for testgenes present in intersects, listing in right order
rightorder <- as.numeric (rownames (dforder1))
lengthrightorder <- length (rightorder)
intersectgeneordered_list <- list ()
for (i in 1:lengthrightorder) {
intersectgeneordered_list [[i]] <-
intersectgene_list [[rightorder [i]]]
}
rownames (dforder1) <- 1:dim (dforder1) [1]
###############################################################################
#### selecting top 20 profiles, aggregating genes for maximal correlation value
#### and saving in selectedprofiles_list
###############################################################################
bestprofilenrs <- dforder1$profilenr [1:20]
selectedprofiles_list <- list ()
counternew <- 0
for (j in bestprofilenrs) {
counternew <-
counternew + 1 ;selectedprofiles_list [[counternew]] <-
aggregate (
allprofiles_list[[j]] [,1], by = list (IDENTIFIER = allprofiles_list [[j]] [,2]), FUN = max
)
}
###############################################################################
#### averaging selected gene expression correlation profiles"
###############################################################################
averageprofile_df <- list ()
mergedprofiles_df <- as.data.frame (identifiers)
colnames (mergedprofiles_df) <- "IDENTIFIER"
lengthbestprofilenrs <- length (bestprofilenrs)
for (j in 1:lengthbestprofilenrs) {
mergedprofiles_df <-
merge  (mergedprofiles_df, selectedprofiles_list [[j]], by = "IDENTIFIER", all.x = TRUE)
}
rlength <- nrow (mergedprofiles_df)
clength <- ncol (mergedprofiles_df)
for (r in 1:rlength)
{
mergedprofiles_df$Correlation [r] <-
rowMeans (mergedprofiles_df [r, 2:clength], na.rm = TRUE)
mergedprofiles_df$supporting_profiles [r] <-
sum (!is.na(mergedprofiles_df [r, 2:clength]))
}
orderedmergedprofiles_df <-
mergedprofiles_df [order (-mergedprofiles_df$Correlation),]
averageprofile_df <-
orderedmergedprofiles_df [, c (1, clength + 1, clength + 2)]
rownames (averageprofile_df) <- 1:length (identifiers)
## saving final results and settings in  Results list,
## but not large allprofiles_list and selectedprofiles_list
Results <- list ()
Results$alldatasetnames <- datasetnames
Results$query <- query
Results$testgenes <- testgenes
Results$topgenesnr <- length (bb)
Results$intersectgenes <- intersectgeneordered_list
Results$rankedprofiles <- dforder1
Results$selectedprofilenrs <- bestprofilenrs
Results$averageprofile_df <- averageprofile_df
names (Results$intersectgenes) <-
as.character (Results$rankedprofiles$profilename)
#### check distribution of intersect sizes, optional, go back to inputs
#### "forintersect" (now 25: line 144) and "bestprofilenrs" (now 1:20: line 187) to optimize
#### and rerun
print ("RANKED CORRELATION PROFILES FOR QUERY GENE ADAMTS2 FROM 30 DATASETS")
print (names (Results))
print (Results$rankedprofiles)
################################
## set minimally required number of supporting profiles for gene in average profile (now 6)
nrofsupportingprofiles <- 6
################################
use <-  Results$averageprofile_df [,3] > nrofsupportingprofiles - 1
print ("AVERAGED RANKED CORRELATION PROFILE FOR QUERY GENE ADAMTS2 FROM 20 PROFILES")
print (Results$averageprofile_df [use,] [1:50,])
###############################################################################################
#### USING PRECALCULATED averaged profiles on same 30 datasets as used in example ADAMTS2 above
###############################################################################################
##  FIRST WITH GENES USED TO OBTAIN GC SIGNATURE 1
setwd("~/GitHub/GCblood_repo/results/signatures")
forGCsignature1_list <- readRDS ("forGCsignature1.rds")
##   set minimal number of supporting datasets required for all genes present in each averageprofiledf  : use > 5
averageprofile_dfuse <- list ()
for (i in 1:6) {
file <-
forGCsignature1_list [[i]]; averageprofiledf <-
file$averageprofile_df;  use <-
averageprofiledf [,3] > 5 ; averageprofiledfuse <-
averageprofiledf [use,]; averageprofiledfuse$ranking <-
1:dim (averageprofiledfuse) [1]; averageprofile_dfuse [[i]] <-
averageprofiledfuse
}
##  combine 6 averageprofiledf for average of averages
merger1 <-
merge (averageprofile_dfuse [[1]], averageprofile_dfuse [[2]], by = "IDENTIFIER", all = TRUE)
for (i in c (3,4,5,6)) {
merger1 <-
merge (merger1, averageprofile_dfuse [[i]], by = "IDENTIFIER", all = TRUE)
}
merger1$meanranking <-
rowMeans (merger1 [,c (4,7,10,13,16,19)], na.rm = TRUE)
querygenes <- names (forGCsignature1_list)
mergercolnames <-
character () ; for (i in querygenes) {
begin <-
paste (c ("cor", "nr", "rank"), i, sep = "."); mergercolnames <-
c (mergercolnames, begin)
}
merger1order <-
merger1 [order (merger1$meanranking, decreasing = FALSE),]
colnames (merger1order) <- c ("gene", mergercolnames,"mean.rank")
rownames (merger1order) <- 1:dim (merger1order) [1]
merger1order$rank.mean <- 1:dim (merger1order) [1]
##########
#### remove genes supported by too few profiles in total from all query genes
####
merger1order$sumofsupportingprofiles <- rowSums(merger1order [,c (3,6,9,12,15,18)], na.rm = TRUE)
hitwithmostgenequeries <- merger1order$sumofsupportingprofiles > 5*length (querygenes)
merger2order <- merger1order [hitwithmostgenequeries,]
rownames (merger2order) <- 1:dim (merger2order) [1]
merger2order$rank.mean <- 1:dim (merger2order) [1]
##########
print ("RANKED PROFILES FOR 6 GC SIGNATURE 1 QUERY GENES AND RANKED AVERAGED PROFILE")
print (head (merger2order))
print (merger2order [1:50, c (1, 20)])
##  SECOND WITH GENES USED TO OBTAIN GC SIGNATURE 2
setwd("~/GitHub/GCblood_repo/results/signatures")
forGCsignature2_list <- readRDS ("forGCsignature2.rds")
## set minimal number of supporting datasets required for all genes present in each averageprofiledf  : use > 5
averageprofile_dfuse <- list ()
for (i in 1:7) {
file <-
forGCsignature2_list [[i]]; averageprofiledf <-
file$averageprofile_df;  use <-
averageprofiledf [,3] > 5 ; averageprofiledfuse <-
averageprofiledf [use,]; averageprofiledfuse$ranking <-
1:dim (averageprofiledfuse) [1]; averageprofile_dfuse [[i]] <-
averageprofiledfuse
}
##  combine 7 averageprofiledf for average of averages
querygenes <- names (forGCsignature2_list)
merger1 <-
merge (averageprofile_dfuse [[1]], averageprofile_dfuse [[2]], by = "IDENTIFIER", all = TRUE)
for (i in c (3:7)) {
merger1 <-
merge (merger1, averageprofile_dfuse [[i]], by = "IDENTIFIER", all = TRUE)
}
merger1$meanranking <-
rowMeans (merger1 [,c (4,7,10,13,16,19,22)], na.rm = TRUE)
mergercolnames <-
character () ; for (i in querygenes) {
begin <-
paste (c ("cor", "nr", "rank"), i, sep = "."); mergercolnames <-
c (mergercolnames, begin)
}
merger1order <-
merger1 [order (merger1$meanranking, decreasing = FALSE),]
colnames (merger1order) <- c ("gene", mergercolnames,"mean.rank")
rownames (merger1order) <- 1:dim (merger1order) [1]
merger1order$rank.mean <- 1:dim (merger1order) [1]
##########
#### remove genes supported by too few profiles in total from all query genes
####
merger1order$sumofsupportingprofiles <- rowSums(merger1order [,c (3,6,9,12,15,18,21)], na.rm = TRUE)
hitwithmostgenequeries <- merger1order$sumofsupportingprofiles > 5*length (querygenes)
merger2order <- merger1order [hitwithmostgenequeries,]
rownames (merger2order) <- 1:dim (merger2order) [1]
merger2order$rank.mean <- 1:dim (merger2order) [1]
#####
print ("RANKED PROFILES FOR 7 GC SIGNATURE 2 QUERY GENES AND RANKED AVERAGED PROFILE")
print (head (merger2order))
print (merger2order [1:50, c (1, 23)])
######################################################################################
##################### END
######################################################################################
rm (list = ls ())
#### CALCULATES GENE EXPRESSION CORRELATION PROFILES AVERAGED OVER 15 DATASETS
################################################################################
#### script suitable for both RNA seq and microarray datasets put in GEO datasets (gds) format
#### also handles multiple probes present for single gene in case of microarray data
################################################################################
#### PART 1 : CHOOSE MULTIGENE QUERY, AND DATASET COLLECTIONS
################################################################################
#####################
#### read all gene identifiers (all gene names on platforms GPL570 and GPL10558)
#### No RNAseq datasets are present in the example collection, but otherwise add more RNAseq identifiers
#### to include the more recent HUGO gene names and gene aliases absent from GPL570 and GPL10558
setwd("~/GitHub/GCblood_repo/data")
identifiersGPL570 <- readRDS ("identifiers_gpl570.rds")
identifiersGPL10558 <- readRDS ("identifiers_gpl10558.rds")
identifiers <- unique (c (identifiersGPL570,identifiersGPL10558))
#####################
#####################
#### CHOOSE multigene query (for example either query with TSC22D3 on collection not severe,
#### or query with ADAMTS2 on collection severe)
## query <- c ("TSC22D3","PER1","ZBTB16","KLF9","CXCR4","DDIT4","IRS2")
query <- c ("ARG1")
#####################
####################
#### CHOOSE dataset collections (here either collection not severe or collection severe)
#### by setting datasetnames in lines below
setwd("~/GitHub/GCblood_repo/data/expressiontables_notsevere")
datasetnamesnotsevere <- dir ()
setwd("~/GitHub/GCblood_repo/data/expressiontables_severe")
datasetnamessevere <- dir ()
## datasetnames <- datasetnamesnotsevere
datasetnames <- datasetnamessevere
#####################
################################################################################
#### PART 2 : CALCULATE AVERAGED GENE EXPRESSION CORRELATION PROFILES
################################################################################
query <- intersect (query, identifiers)
querycounter <- 0
querylength <- length (query)
allprofilesallqueries_list <- list ()
averageprofilesallqueries_list <- list ()
counterdown <- length (datasetnames)*querylength
for (querygene in query){
querycounter <- querycounter + 1
#### allprofiles_list will first contain gene expression correlation profiles for all probes
#### corresponding with a single querygene, obtained for all datasets in the collection
allprofiles_list <- list ()
samplesizes <- numeric ()
##### makes room for up to 1000 datasets in collection
namesofdatasets <- rep (c (""), times = 1000)
genename  <- rep (c (""), times = 1000)
datasetnr <- rep (c (0), times = 1000)
nrofqueryprobesindatasets<- rep (c (0), times = 1000)
counterdatasetup = 1
counterprofiles = 1
for (j in datasetnames){
if (j %in% datasetnamesnotsevere)  {setwd("~/GitHub/GCblood_repo/data/expressiontables_notsevere"); expressiontable <- readRDS (j)}
if (j %in% datasetnamessevere)  {setwd("~/GitHub/GCblood_repo/data/expressiontables_severe"); expressiontable <- readRDS (j)}
expressionmatrix <- t (expressiontable [, -c (1,2)])
colnames (expressionmatrix) <- expressiontable [,2]
#### taking probes as rownumbers in original expression table, not as ID_REFS
probes <- which (colnames (expressionmatrix) == querygene)
if (class ( expressionmatrix [,1]) != "numeric") { expressionmatrix <- apply (expressionmatrix, 2, as.numeric)}
probes <- which (colnames (expressionmatrix) == querygene)
probenr <- length(probes)
counterprobesets = 0
namesofdatasets [counterdatasetup] <-  j
genename [counterdatasetup] <- querygene
datasetnr [counterdatasetup] <- counterdatasetup
nrofqueryprobesindatasets [counterdatasetup] <- probenr
for (probe in probes){
correlations_namednum <- cor (expressionmatrix [,probe],expressionmatrix)
b <-  correlations_namednum [1, ]
#### sort to rank all gene probes in profile according to correlation value with querygene probe
correlationsranked_namednum <- - sort (-b)
df <- as.data.frame (correlationsranked_namednum)
df$IDENTIFIER <- names (correlationsranked_namednum)
colnames (df) [1] <-  paste (j, "nr" , probe, sep = "")
allprofiles_list [[counterprobesets + counterprofiles]] <- df
counterprobesets <- counterprobesets +1
}
counterprofiles <- counterprofiles + counterprobesets
counterdown <- counterdown -1
counterdatasetup <- counterdatasetup +1
print ("file reads left to do:")
print (counterdown)
}
#### select best correlation profiles based on consistent results of gene probes in and between datasets
#########################################################################################################
#### calculate mean intersect with other probe profiles for each separate probe profile
#### (take gene intersects of top 200 in ranked profiles)
ll <- length (allprofiles_list)
intersectmatrix <- matrix (nrow = ll, ncol = ll)
for (x in 1:ll){
for(y in 1:ll){
intersectmatrix [x,y]  <- length (intersect (allprofiles_list [[x]][1:200,2], allprofiles_list [[y]][1:200,2]))
}
}
intersectmatrix[ row(intersectmatrix) == col(intersectmatrix) ] <- 0
####  to plot intersect matrix for visual :
##  image (intersectmatrix)
kolmeans <- colMeans (intersectmatrix)
#### discarding inadequate probe profiles with low mean intersect of 5 or less
setnumber <- rep (as.numeric (datasetnr), times = (as.numeric(nrofqueryprobesindatasets)))
profilescore <- cbind (setnumber, kolmeans)
profilescore <- as.data.frame (profilescore)
datasetnrsused <- unique (profilescore$setnumber)
#### allprofilesallqueries_list will contain gene expression correlation profiles for all probes
#### corresponding with all querygenes, obtained for all datasets in the collection
allprofilesallqueries_list [[querycounter]] <- allprofiles_list
vectorintall1 <- as.integer ()
for (xx1 in datasetnrsused){
aa1 <- which (profilescore$setnumber == xx1)
use <-profilescore$kolmeans [aa1]     >5
vectorint1 <- aa1 [use]
vectorintall1 <- c (vectorintall1, vectorint1)
}
#### taking best probe profile for each dataset
vectorintall2 <- as.integer ()
for (xx2 in datasetnrsused){
aa2 <- which (profilescore$setnumber == xx2)
use <-profilescore$kolmeans [aa2] == max (profilescore$kolmeans [aa2])
#### in case of identical maxima in one dataset, only first profile used ([1])
vectorint2 <- aa2 [use] [1]
vectorintall2 <- c (vectorintall2, vectorint2)
}
#### only keeping one best probe profile for each dataset and probe should be adequate
#### if best probe in a dataset is inadequate, the profile (and corresponding dataset) is not used
filter <- intersect (vectorintall1, vectorintall2)
checkfilter <- filter
#### keep running, in case all probes for a querygene are inadequate in all (but one) datasets, remove later
checkvalues <- numeric () ; for (p in 1:ll) {checkvalue <- allprofiles_list [[p]] [1,1]; checkvalues <- c (checkvalues, checkvalue)}
valuesone <- which (checkvalues == 1)
if (length (filter) == 0){filter <- valuesone [1:2]}
if (length (filter) == 1){filter <- valuesone [1:2]}
#### for each gene in selected profiles uses the probe with maximal correlation value with the querygene
#########################################################################################################
#### CHOOSE, if especially checking for negative correlations (tails) set: FUN = min
for (j in filter){
allprofiles_list [[j]] <- aggregate (allprofiles_list[[j]] [,1], by = list (IDENTIFIER = allprofiles_list [[j]] [,2]), FUN = max)
}
#### use selected profiles to obtain one combined (merged) profile from all datasets with mean correlation values
#########################################################################################################
mergedprofiles_df <- as.data.frame (identifiers)
colnames (mergedprofiles_df) <- "IDENTIFIER"
for (j in filter){
mergedprofiles_df <- merge  (mergedprofiles_df, allprofiles_list [[j]], by = "IDENTIFIER", all.x = TRUE )
}
rlength <- nrow (mergedprofiles_df)
clength <- ncol (mergedprofiles_df)
for ( r in 1: rlength)
{mergedprofiles_df$Correlation [r] <-  rowMeans (mergedprofiles_df [r, 2:clength], na.rm = TRUE)
mergedprofiles_df$supporting_datasets [r] <- sum (!is.na(mergedprofiles_df [r, 2:clength]))
}
#### sort to rank all genes in combined profile according to mean correlation values with querygene
orderedmergedprofiles_df <- mergedprofiles_df [order (-mergedprofiles_df$Correlation), ]
averageprofiledf <- orderedmergedprofiles_df [, c (1, clength +1, clength + 2)]
rownames (averageprofiledf) <- 1: length (identifiers)
#### averageprofilesallqueries_list will, for each querygene, contain a single averaged gene expression correlation profile
#### using all datasets in the collection
averageprofilesallqueries_list [[querycounter]] <- averageprofiledf
if (length (checkfilter) == 0) {averageprofilesallqueries_list [[querycounter]] <- "no hits above threshold set at 5"}
if (length (checkfilter) == 1) {averageprofilesallqueries_list [[querycounter]] <- "just one hit above threshold set at 5"}
print (paste (query [querycounter], "done", sep = " "))
}
names (averageprofilesallqueries_list) <- query
################################################################################
#### PART 3 : PRINT RESULTS FOR AVERAGED GENE EXPRESSION CORRELATION PROFILES
################################################################################
####  in case of query genes without a resulting profile
usegood <- logical() ; for (i in 1:querylength){useg <- class (averageprofilesallqueries_list [[i]])!= "character"; usegood <- c (usegood,useg)}
usebad <- usegood == FALSE
allquerynumbers <- 1:querylength
goodquerynumbers <- allquerynumbers [usegood]
badquerynumbers <- allquerynumbers [usebad]
#### only shows results supported by more than 5 datasets in dataset collection (use >5)
for (i in goodquerynumbers){use <- averageprofilesallqueries_list [[i]] [,3] >5; print (averageprofilesallqueries_list [[i]] [use,][1:25,])}
#### in case code above was run with aggregate set to minus to see negative correlations (tails):
##   for (i in goodquerynumbers){use <- averageprofilesallqueries_list [[i]] [,3] >5; aa <- averageprofilesallqueries_list [[i]] [use,]; bb <- dim (aa) [1]; print (names (averageprofilesallqueries_list) [i]); cc <- bb-25 ;print (aa [bb:cc,])}
for (i in badquerynumbers) {print (query [i]); print (head (averageprofilesallqueries_list [[i]]))}
################################################################################
#### END
################################################################################
rm (list = ls ())
############ SHOWS GC Signatures 1 and 2  using 2 separate dataset collections
############ GC 1 Signature using multigene query 1 (n=6) on dataset collection not severe (n=15)
############ GC 2 Signature using multigene query 2 (n=7) on dataset collection severe (n=15)
#####################################################
############ PART1 COMBINING GENE PROFILES
#####################################################
setwd("~/GitHub/GCblood_repo/results/fromseparatecollections")
averagenotsevere_list  <- readRDS ("average_correlations_notsevere.rds")
##   set use > 5
averageprofile_dfuse <- list ()
for (i in 1:7){averagedf <- averagenotsevere_list [[i]];   use <- averagedf [,3] > 5 ; averagedfuse <- averagedf [use,]; averagedfuse$ranking <- 1:dim (averagedfuse) [1]; averageprofile_dfuse [[i]] <- averagedfuse }
#### using 6 query genes for GC signature 1:
#### PER1, ZBTB16, DDIT4, TSC22D3, KLF9, IRS2
merger1 <- merge (averageprofile_dfuse [[1]], averageprofile_dfuse [[2]], by = "IDENTIFIER", all = TRUE)
for (i in c (3:6)) {merger1 <- merge (merger1, averageprofile_dfuse [[i]], by = "IDENTIFIER", all = TRUE)}
merger1$meanranking <- rowMeans (merger1 [,c (4,7,10,13,16,19)], na.rm = TRUE)
querygenes <- names (averagenotsevere_list) [1:6]
kolnames1 <- character () ; for (i in querygenes) {begin <- paste (c ("cor", "nr", "rank"), i, sep = "."); kolnames1 <- c (kolnames1, begin)}
merger1order <- merger1 [order (merger1$meanranking, decreasing = FALSE),]
colnames (merger1order) <- c ("gene", kolnames1,"mean.rank")
rownames (merger1order) <- 1:dim (merger1order) [1]
##########
#### remove genes supported by too few datasets in total from all query genes
####
merger1order$sumofsupportingdatasets <- rowSums(merger1order [,c (3,6,9,12,15,18)], na.rm = TRUE)
hitwithmostgenequeries <- merger1order$sumofsupportingdatasets > 5 * length (querygenes)
merger2order <- merger1order [hitwithmostgenequeries,]
rownames (merger2order) <- 1:dim (merger2order) [1]
merger2order$rank.mean <- 1:dim (merger2order) [1]
print ("RANKED PROFILES FOR 6 GC SIGNATURE 1 QUERY GENES AND RANKED AVERAGED PROFILE")
print (head (merger2order))
print (merger2order [1:50, c (1, 20)])
##  nu GC signature voor severe op 15, check ook in scan code dan
setwd("~/GitHub/GCblood_repo/results/fromseparatecollections")
averagesevere_list <- readRDS ("average_correlations_severe.rds")
##   set use > 5
averageprofile_dfuse <- list ()
for (i in 1:10){averagedf <- averagesevere_list [[i]];  use <- averagedf [,3] > 5 ; averagedfuse <- averagedf [use,]; averagedfuse$ranking <- 1:dim (averagedfuse) [1]; averageprofile_dfuse [[i]] <- averagedfuse }
#### using 7 query genes for GC signature 2:
#### FLT3, ADORA3, CD163, OLAH, DAAM2, ADAMTS2, VSIG4
merger1 <- merge (averageprofile_dfuse [[1]], averageprofile_dfuse [[2]], by = "IDENTIFIER", all = TRUE)
for (i in c (3:7)) {merger1 <- merge (merger1, averageprofile_dfuse [[i]], by = "IDENTIFIER", all = TRUE)}
merger1$meanranking <- rowMeans (merger1 [,c (4,7,10,13,16,19,22)], na.rm = TRUE)
querygenes <- names (averagesevere_list) [1:7]
kolnames1 <- character () ; for (i in querygenes) {begin <- paste (c ("cor", "nr", "rank"), i, sep = "."); kolnames1 <- c (kolnames1, begin)}
merger1order <- merger1 [order (merger1$meanranking, decreasing = FALSE),]
colnames (merger1order) <- c ("gene", kolnames1,"mean.rank")
rownames (merger1order) <- 1:dim (merger1order) [1]
merger1order$rank.mean <- 1:dim (merger1order) [1]
##########
#### remove genes supported by too few datasets in total from all query genes
####
merger1order$sumofsupportingdatasets <- rowSums(merger1order [,c (3,6,9,12,15,18,21)], na.rm = TRUE)
hitwithmostgenequeries <- merger1order$sumofsupportingdatasets > 5 * length (querygenes)
merger2order <- merger1order [hitwithmostgenequeries,]
rownames (merger2order) <- 1:dim (merger2order) [1]
merger2order$rank.mean <- 1:dim (merger2order) [1]
print ("RANKED PROFILES FOR 7 GC SIGNATURE 2 QUERY GENES AND RANKED AVERAGED PROFILE")
print (head (merger2order))
print (merger2order [1:50, c (1, 23)])
#####################################################
############ PART2 MATRIX FOR RECIPROCAL RANKING OF GENES IN PROFILES
#####################################################
########## matrix for biomarker set GC-1
########################################
setwd("~/GitHub/GCblood_repo/results/fromseparatecollections")
averagenotsevere_list  <- readRDS ("average_correlations_notsevere.rds" )
query <- names (averagenotsevere_list)
querylength <- length (query)
averageprofile_dfuse <- list ()
## vaanglijstuse <- list ()
##  check nog of use groter 5 beter is dan groter 2
for (i in 1:querylength) {use <- averagenotsevere_list [[i]] [,3] > 5 ; averagedfuse <- averagenotsevere_list [[i]] [use,]; averagedfuse$ranking <- 1:dim (averagedfuse) [1];averageprofile_dfuse [[i]] <- averagedfuse}
## > for (i in 1:10){print (vaanglijstuse [[i]] [1:10,])}
querydf <- as.data.frame (query)
colnames (querydf) [1] <- "IDENTIFIER"
merger1 <- merge (querydf,averageprofile_dfuse [[1]] [,c (1,4)], by = "IDENTIFIER",all.x = TRUE)
for (j in 2:querylength){ merger1 <- merge (merger1,averageprofile_dfuse [[j]] [,c (1,4)], by = "IDENTIFIER",all.x = TRUE)}
colnames (merger1) <- c ("gene", query)
genesnow <- as.character (merger1$gene)
rightorder <- numeric (); for (i in query){thisone <- which (genesnow == i); rightorder <- c (rightorder, thisone)}
merger2 <- merger1 [rightorder,]
rownames (merger2) <- as.character (merger2$gene)
merger3 <- merger2 [,-1]
## transpose to have profiles in rows, asymmetric square matrix
reciprocal_mat <- t (merger3)
print (reciprocal_mat )
########## matrix for biomarker set GC-2
########################################
#####################################################################
setwd("~/GitHub/GCblood_repo/results/fromseparatecollections")
## averagesevere_list  <- readRDS ("average_correlations_notsevere.rds")
averagesevere_list  <- readRDS ("average_correlations_severe.rds" )
query <- names (averagesevere_list)
querylength <- length (query)
averageprofile_dfuse <- list ()
## vaanglijstuse <- list ()
##  check nog of use groter 5 beter is dan groter 2
for (i in 1:querylength) {use <- averagesevere_list [[i]] [,3] > 5 ; averagedfuse <- averagesevere_list [[i]] [use,]; averagedfuse$ranking <- 1:dim (averagedfuse) [1];averageprofile_dfuse [[i]] <- averagedfuse}
## > for (i in 1:10){print (vaanglijstuse [[i]] [1:10,])}
querydf <- as.data.frame (query)
colnames (querydf) [1] <- "IDENTIFIER"
merger1 <- merge (querydf,averageprofile_dfuse [[1]] [,c (1,4)], by = "IDENTIFIER",all.x = TRUE)
for (j in 2:querylength){ merger1 <- merge (merger1,averageprofile_dfuse [[j]] [,c (1,4)], by = "IDENTIFIER",all.x = TRUE)}
colnames (merger1) <- c ("gene", query)
genesnow <- as.character (merger1$gene)
rightorder <- numeric (); for (i in query){thisone <- which (genesnow == i); rightorder <- c (rightorder, thisone)}
merger2 <- merger1 [rightorder,]
rownames (merger2) <- as.character (merger2$gene)
merger3 <- merger2 [,-1]
## transpose to have profiles in rows, asymmetric square matrix
reciprocal_mat <- t (merger3)
#### leave out CD163, not in biomarker set GC-2
print (reciprocal_mat [-2,-2])
#########################################
###########  END
#########################################
